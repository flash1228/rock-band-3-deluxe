{new
   MidiParser
   guitar_timer
   (track_name 'PART GUITAR')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   (message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (96 97 98 99 100 103 120) ;103 = solo, 120 = lowest of BRE
   )
   (midi
      {unless $first_guitar_gem_tracked
         {set $first_guitar_gem_tracked TRUE}
         {set $tracked_break_num_guitar 0}
         {set $first_guitar_gem_beat {int $mp.start}}
         {set $dx_last_note_started_guitar 0} ; cache note start time
         {if {> $first_guitar_gem_beat 16}
            {push_back $guitar_note_tracker ("delay_0" 0 $first_guitar_gem_beat)}
            {set $guitar_note_tracker {array $guitar_note_tracker}}
            {set $tracked_break_num_guitar 1}
         }
      }
      {if {&& {>= $mp.prev_end 16} {< $mp.prev_end 10000}}
         {set $guitar_tracked_start {int $mp.start}}
         {set $guitar_tracked_prev_end {int {- $guitar_tracked_start $mp.prev_end}}}
         {push_back $guitar_note_tracker ({sprint "delay_" $tracked_break_num_guitar} $guitar_tracked_prev_end $guitar_tracked_start)}
         {set $guitar_note_tracker {array $guitar_note_tracker}}
         {set $tracked_break_num_guitar {+ $tracked_break_num_guitar 1}}
      }
      {set $dx_final_note_guitar {int $mp.end}}
      {if {> $dx_final_note_guitar $dx_final_note} {set $dx_final_note $dx_final_note_guitar}}
      {if $dx_perfects_indicator
         {if {|| {== $mp.val 96} {== $mp.val 97} {== $mp.val 98} {== $mp.val 99} {== $mp.val 100}}
            {if {> {- $mp.start $dx_last_note_started_guitar} 0}
               {push_back $guitar_note_tracker_2 {* {beat_to_seconds $mp.start} 1000}}
               {set $guitar_note_tracker_2_size {size $guitar_note_tracker_2}}
               {set $dx_last_note_started_guitar $mp.start} ; cache note start time
            }
         }
      }
      
   )
}
{new
   MidiParser
   guitar_overdrive_timer
   (track_name 'PART GUITAR')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (116)
   )
   (midi
      {push_back $guitar_note_tracker ({sprint "overdrive_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $guitar_note_tracker {array $guitar_note_tracker}}
   )
}
{new
   MidiParser
   guitar_solo_timer
   (track_name 'PART GUITAR')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (103)
   )
   (midi
      {push_back $guitar_note_tracker ({sprint "solo_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $guitar_note_tracker {array $guitar_note_tracker}}
   )
}
{new
   MidiParser
   real_guitar_timer
   (track_name 'PART REAL_GUITAR')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (96 97 98 99 100 101 120) ;120: BRE
   )
   (midi
      {unless $first_real_guitar_gem_tracked
         {set $first_real_guitar_gem_tracked TRUE}
         {set $tracked_break_num_real_guitar 0}
         {set $dx_last_note_started_real_guitar 0} ; cache note start time
         {set $first_real_guitar_gem_beat {int $mp.start}}
         {if {> $first_real_guitar_gem_beat 16}
            {push_back $real_guitar_note_tracker ("delay_0" 0 $first_real_guitar_gem_beat)}
            {set $real_guitar_note_tracker {array $real_guitar_note_tracker}}
            {set $tracked_break_num_real_guitar 1}
         }
      }
      {if {&& {>= $mp.prev_end 16} {< $mp.prev_end 10000}}
         {set $real_guitar_tracked_start {int $mp.start}}
         {set $real_guitar_tracked_prev_end {int {- $real_guitar_tracked_start $mp.prev_end}}}
         {push_back $real_guitar_note_tracker ({sprint "delay_" $tracked_break_num_real_guitar} $real_guitar_tracked_prev_end $real_guitar_tracked_start)}
         {set $real_guitar_note_tracker {array $real_guitar_note_tracker}}
         {set $tracked_break_num_real_guitar {+ $tracked_break_num_real_guitar 1}}
      }
      {set $dx_final_note_real_guitar {int $mp.end}}
      {if {> $dx_final_note_real_guitar $dx_final_note} {set $dx_final_note $dx_final_note_real_guitar}}
      {if $dx_perfects_indicator
         {if {|| {== $mp.val 96} {== $mp.val 97} {== $mp.val 98} {== $mp.val 99} {== $mp.val 100} {== $mp.val 101}}
            {if {> {- $mp.start $dx_last_note_started_real_guitar} 0}
               {push_back $real_guitar_note_tracker_2 {* {beat_to_seconds $mp.start} 1000}}
               {set $real_guitar_note_tracker_2_size {size $real_guitar_note_tracker_2}}
               {set $dx_last_note_started_real_guitar $mp.start} ; cache note start time
            }
         }
      }
   )
}
{new
   MidiParser
   real_guitar_overdrive_timer
   (track_name 'PART REAL_GUITAR')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (116)
   )
   (midi
      {push_back $real_guitar_note_tracker ({sprint "overdrive_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $real_guitar_note_tracker {array $real_guitar_note_tracker}}
   )
}
{new
   MidiParser
   real_guitar_solo_timer
   (track_name 'PART REAL_GUITAR')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (115)
   )
   (midi
      {push_back $real_guitar_note_tracker ({sprint "solo_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $real_guitar_note_tracker {array $real_guitar_note_tracker}}
   )
}
{new
   MidiParser
   bre_timer
   (track_name 'PART GUITAR')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (120)
   )
   (midi
      {push_back $guitar_note_tracker ({sprint "bre_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $guitar_note_tracker {array $guitar_note_tracker}}
      {push_back $bass_note_tracker ({sprint "bre_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $bass_note_tracker {array $bass_note_tracker}}
      {push_back $drum_note_tracker ({sprint "bre_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $drum_note_tracker {array $drum_note_tracker}}
      {push_back $keys_note_tracker ({sprint "bre_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $keys_note_tracker {array $keys_note_tracker}}
      {push_back $vocals_note_tracker ({sprint "bre_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $vocals_note_tracker {array $vocals_note_tracker}}
      {push_back $harm_note_tracker ({sprint "bre_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $harm_note_tracker {array $harm_note_tracker}}
   )
}
{new
   MidiParser
   drum_timer
   (track_name 'PART DRUMS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      #ifdef RB3E
      {if_else {dx_check_rb3e_modifier mod_double_bass}
         (95 96 97 98 99 100 103 120)
         (96 97 98 99 100 103 120)
      }
      #else
      (96 97 98 99 100 103 120)
      #endif
   )
   (midi
      {unless $first_drum_gem_tracked
         {set $first_drum_gem_tracked TRUE}
         {set $dx_capture_drum TRUE}
         {set $tracked_break_num_drum 0}
         {set $first_drum_gem_beat {int $mp.start}}
         {set $dx_last_kick_ended 0}
         {set $dx_last_note_started_drum 0} ; cache note end time
         {if {> $first_drum_gem_beat 16}
            {push_back $drum_note_tracker ("delay_0" 0 $first_drum_gem_beat)}
            {set $drum_note_tracker {array $drum_note_tracker}}
            {set $tracked_break_num_drum 1}
         }
      }
      {if {&& {>= $mp.prev_end 16} {< $mp.prev_end 10000}}
         {set $drum_tracked_start {int $mp.start}}
         {set $drum_tracked_prev_end {int {- $drum_tracked_start $mp.prev_end}}}
         {push_back $drum_note_tracker ({sprint "delay_" $tracked_break_num_drum} $drum_tracked_prev_end $drum_tracked_start)}
         {set $drum_note_tracker {array $drum_note_tracker}}
         {set $tracked_break_num_drum {+ $tracked_break_num_drum 1}}
      }
      {set $dx_final_note_drum {int $mp.end}}
      {if {> $dx_final_note_drum $dx_final_note} {set $dx_final_note $dx_final_note_drum}}
      {if $dx_perfects_indicator
         {if {|| #ifdef RB3E {&& {== $mp.val 95} {dx_check_rb3e_modifier mod_double_bass}} #endif {== $mp.val 96} {== $mp.val 97} {== $mp.val 98} {== $mp.val 99} {== $mp.val 100}}
            {if {< {- $mp.start $dx_last_note_started_drum} 0}
               {set $dx_capture_drum FALSE} ;will be triggered the first time the parser jumps to the beginning after having completed the mid
            }
            {if {&& $dx_capture_drum {>= {- $mp.end $dx_last_note_started_drum} 0}}
               {unless {&& {|| {== $mp.val 95} {== $mp.val 96}} {< {- $mp.start $dx_last_kick_ended} 0}} ;workaround for RB3E 2x kick overlapping notes which are dropped by the RB3 engine
                  {push_back $drum_note_tracker_2 {* {beat_to_seconds $mp.start} 1000}}
                  {set $drum_note_tracker_2_size {size $drum_note_tracker_2}} 
               
                  ;{if {== $drum_note_tracker_2_size 1}
                  ;   {dx_log_writer countdown {sprint "NoteID,Time,End,dx_last_note_started_drum,mp.start,mp.end,mp.length,mp.prev_start,mp.prev_end,mp.data,mp.val"}}
                  ;}
                  ;{if {<= $drum_note_tracker_2_size 4000}
                  ;   {dx_log_writer countdown {sprint $drum_note_tracker_2_size "," {* {beat_to_seconds $mp.start} 1000} "," {* {beat_to_seconds $mp.end} 1000} "," $dx_last_note_started_drum "," $mp.start "," $mp.end "," $mp.length "," $mp.prev_start "," $mp.prev_end "," $mp.data "," $mp.val }}
                  ;}
                  {set $dx_last_note_started_drum {int $mp.start}}
                  {if {|| {== $mp.val 95} {== $mp.val 96}}
                     {set $dx_last_kick_ended $mp.end}
                  }
               }
            }
         }
      }
      {set $dx_final_note_real_drum $dx_final_note_drum}
      {set $real_drum_note_tracker_2 $drum_note_tracker_2}
      {set $real_drum_note_tracker $drum_note_tracker}
      {set $real_drum_note_tracker_2_size $drum_note_tracker_2_size}
   )
}
{new
   MidiParser
   drum_overdrive_timer
   (track_name 'PART DRUMS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (116)
   )
   (midi
      {push_back $drum_note_tracker ({sprint "overdrive_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $drum_note_tracker {array $drum_note_tracker}}
   )
}
{new
   MidiParser
   drum_solo_timer
   (track_name 'PART DRUMS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (103)
   )
   (midi
      {push_back $drum_note_tracker ({sprint "solo_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $drum_note_tracker {array $drum_note_tracker}}
   )
}
{new
   MidiParser
   bass_timer
   (track_name 'PART BASS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (96 97 98 99 100 103 120) ;103: solo, 120: BRE
   )
   (midi
      {unless $first_bass_gem_tracked
         {set $first_bass_gem_tracked TRUE}
         {set $tracked_break_num_bass 0}
         {set $dx_last_note_started_bass 0} ; cache note start time
         {set $first_bass_gem_beat {int $mp.start}}
         {if {> $first_bass_gem_beat 16}
            {push_back $bass_note_tracker ("delay_0" 0 $first_bass_gem_beat)}
            {set $bass_note_tracker {array $bass_note_tracker}}
            {set $tracked_break_num_bass 1}
         }
      }
      {if {&& {>= $mp.prev_end 16} {< $mp.prev_end 10000}}
         {set $bass_tracked_start {int $mp.start}}
         {set $bass_tracked_prev_end {int {- $bass_tracked_start $mp.prev_end}}}
         {push_back $bass_note_tracker ({sprint "delay_" $tracked_break_num_bass} $bass_tracked_prev_end $bass_tracked_start)}
         {set $bass_note_tracker {array $bass_note_tracker}}
         {set $tracked_break_num_bass {+ $tracked_break_num_bass 1}}
      }
      {set $dx_final_note_bass {int $mp.end}}
      {if {> $dx_final_note_bass $dx_final_note} {set $dx_final_note $dx_final_note_bass}}
      {if $dx_perfects_indicator
         {if {|| {== $mp.val 96} {== $mp.val 97} {== $mp.val 98} {== $mp.val 99} {== $mp.val 100}}
            {if {> {- $mp.start $dx_last_note_started_bass} 0}
               {push_back $bass_note_tracker_2 {* {beat_to_seconds $mp.start} 1000}}
               {set $bass_note_tracker_2_size {size $bass_note_tracker_2}}
               {set $dx_last_note_started_bass $mp.start} ; cache note start time
            }
         }
      }
   )
}
{new
   MidiParser
   bass_overdrive_timer
   (track_name 'PART BASS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (116)
   )
   (midi
      {push_back $bass_note_tracker ({sprint "overdrive_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $bass_note_tracker {array $bass_note_tracker}}
   )
}
{new
   MidiParser
   bass_solo_timer
   (track_name 'PART BASS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (103)
   )
   (midi
      {push_back $bass_note_tracker ({sprint "solo_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $bass_note_tracker {array $bass_note_tracker}}
   )
}
{new
   MidiParser
   real_bass_timer
   (track_name 'PART REAL_BASS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (96 97 98 99 100 101 103 120) ;120: BRE
   )
   (midi
      {unless $first_real_bass_gem_tracked
         {set $first_real_bass_gem_tracked TRUE}
         {set $tracked_break_num_real_bass 0}
         {set $dx_last_note_started_real_bass 0} ; cache note start time
         {set $first_real_bass_gem_beat {int $mp.start}}
         {if {> $first_real_bass_gem_beat 16}
            {push_back $real_bass_note_tracker ("delay_0" 0 $first_real_bass_gem_beat)}
            {set $real_bass_note_tracker {array $real_bass_note_tracker}}
            {set $tracked_break_num_real_bass 1}
         }
      }
      {if {&& {>= $mp.prev_end 16} {< $mp.prev_end 10000}}
         {set $real_bass_tracked_start {int $mp.start}}
         {set $real_bass_tracked_prev_end {int {- $real_bass_tracked_start $mp.prev_end}}}
         {push_back $real_bass_note_tracker ({sprint "delay_" $tracked_break_num_real_bass} $real_bass_tracked_prev_end $real_bass_tracked_start)}
         {set $real_bass_note_tracker {array $real_bass_note_tracker}}
         {set $tracked_break_num_real_bass {+ $tracked_break_num_real_bass 1}}
      }
      {set $dx_final_note_real_bass {int $mp.end}}
      {if {> $dx_final_note_real_bass $dx_final_note} {set $dx_final_note $dx_final_note_real_bass}}
      {if $dx_perfects_indicator
         {if {|| {== $mp.val 96} {== $mp.val 97} {== $mp.val 98} {== $mp.val 99} {== $mp.val 100} {== $mp.val 101}}
            {if {> {- $mp.start $dx_last_note_started_real_bass} 0}
               {push_back $real_bass_note_tracker_2 {* {beat_to_seconds $mp.start} 1000}}
               {set $real_bass_note_tracker_2_size {size $real_bass_note_tracker_2}}
               {set $dx_last_note_started_real_bass $mp.start} ; cache note start time
            }
         }
      }
   )
}
{new
   MidiParser
   real_bass_overdrive_timer
   (track_name 'PART REAL_BASS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (116)
   )
   (midi
      {push_back $real_bass_note_tracker ({sprint "overdrive_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $real_bass_note_tracker {array $real_bass_note_tracker}}
   )
}
{new
   MidiParser
   real_bass_solo_timer
   (track_name 'PART REAL_BASS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (115)
   )
   (midi
      {push_back $real_bass_note_tracker ({sprint "solo_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $real_bass_note_tracker {array $real_bass_note_tracker}}
   )
}
{new
   MidiParser
   keys_timer
   (track_name 'PART KEYS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (96 97 98 99 100 120) ;120: lowest BRE
   )
   (midi
      ;{$this rt_compute_space}
      {unless $first_keys_gem_tracked
         {set $first_keys_gem_tracked TRUE}
         {set $first_note_done_keys FALSE}
         ;{dx_log_writer countdown {sprint "NoteID,Time,End,mp.start,mp.end,dx_batch_start_beat_keys,mp.length,mp.prev_start,mp.prev_end,mp.data,mp.val"}}
         {set $tracked_break_num_keys 0}
         {set [dx_batch_start_beat_keys] -1}
         {set [batch_notes_keys] {array ()}}
         {set [log_enabled_keys] TRUE}
         {set $first_keys_gem_beat {int $mp.start}}
         {if {> $first_keys_gem_beat 16}
            {push_back $keys_note_tracker ("delay_0" 0 $first_keys_gem_beat)}
            {set $keys_note_tracker {array $keys_note_tracker}}
            {set $tracked_break_num_keys 1}
         }
      }
      {if {&& {>= $mp.prev_end 16} {< $mp.prev_end 10000}}
         {set $keys_tracked_start {int $mp.start}}
         {set $keys_tracked_prev_end {int {- $keys_tracked_start $mp.prev_end}}}
         {push_back $keys_note_tracker ({sprint "delay_" $tracked_break_num_keys} $keys_tracked_prev_end $keys_tracked_start)}
         {set $keys_note_tracker {array $keys_note_tracker}}
         {set $tracked_break_num_keys {+ $tracked_break_num_keys 1}}
      }
      {set $dx_final_note_keys {int $mp.end}}
      {if {> $dx_final_note_keys $dx_final_note} {set $dx_final_note $dx_final_note_keys}}
      {if $dx_perfects_indicator
         ;Thanks ChatGPT
         ; Only parse KEYS notes 96–100
         {if {|| {== $mp.val 96} {== $mp.val 97} {== $mp.val 98} {== $mp.val 99} {== $mp.val 100}}
            {if [log_enabled_keys]
               {set [log_enabled_keys] {if_else {< {beat_to_seconds $mp.start} 60}
                                        TRUE
                                        FALSE}
               }
            }
            ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "starting parsing note"}}}
            ;{if {<= $keys_note_tracker_2_size 4000}
               ;{if [log_enabled_keys] {dx_log_writer countdown {sprint $keys_note_tracker_2_size "," {* {beat_to_seconds $mp.start} 1000} "," {* {beat_to_seconds $mp.end} 1000} "," $mp.start "," $mp.end "," [dx_batch_start_beat_keys] "," $mp.length "," $mp.prev_start "," $mp.prev_end "," $mp.data "," $mp.val }}}
            ;}

            ; If this note starts a new batch
            {if {> {- $mp.start [dx_batch_start_beat_keys]} 0.02}
               ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "new start time, process batch of " {size [batch_notes_keys]} " notes"}}}
               
               ; Process previous batch (if any)
               {if {> {size [batch_notes_keys]} 0}
                  {set [diff_end_found_keys] FALSE}
                  {if {> {size [batch_notes_keys]} 1}
                     ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "set $first_end to " {elem {elem [batch_notes_keys] 0} 1} }}}
                     {set $first_end {elem {elem [batch_notes_keys] 0} 1}}
                     {foreach $n [batch_notes_keys] 
                        ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "checking note " $n " for different end time, using value " {elem $n 1}}}}
                        {if {!= {elem $n 1} $first_end}
                           {set [diff_end_found_keys] TRUE}
                        }
                     }
                     ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "[diff_end_found_keys] = " [diff_end_found_keys]}}}
                  }

                  ; Push all notes if there's a differing end
                  {if_else {== [diff_end_found_keys] TRUE}
                     {foreach $n [batch_notes_keys] {do
                        ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "pushing back note with time " {elem $n 0}}}}
                        {push_back $keys_note_tracker_2 {* {beat_to_seconds {elem $n 0}} 1000}}
                     }}
                     {do
                        {set $n {elem [batch_notes_keys] 0}}
                        ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "pushing back singular note with time " {elem $n 0}}}}
                        {push_back $keys_note_tracker_2 {* {beat_to_seconds {elem $n 0}} 1000}}
                     }
                  }
                  
                  {set $keys_note_tracker_2_size {size $keys_note_tracker_2}}
                  ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "set $keys_note_tracker_2_size = " $keys_note_tracker_2_size}}}
               }

               ; Start new batch
               ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "set [dx_batch_start_beat_keys] to " $mp.start}}}
               {set [dx_batch_start_beat_keys] $mp.start}
               ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "[dx_batch_start_beat_keys] = " [dx_batch_start_beat_keys] ", set [batch_notes_keys] to empty array"}}}
               {set [batch_notes_keys] {array ()}} ; Clear batch
            }

            ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "push back $dx_keys_note to [batch_notes_keys]"}}}
            {set [dx_do_add_note_keys] TRUE}
            {if {> {size [batch_notes_keys]} 0}
               {foreach $n [batch_notes_keys]
                  ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "Checking for no matching note val " {elem $n 2}}}}
                  {if {== {elem $n 2} $mp.val}
                     ;{dx_log_writer countdown {sprint "Second+ note with same start-time and val, skipping!"}}
                     {set [dx_do_add_note_keys] FALSE}
                  }
               }
            }
            {if {== [dx_do_add_note_keys] TRUE} 
               {set $dx_keys_note {array ($mp.start $mp.end $mp.val)}}
               ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "$dx_keys_note = " $dx_keys_note}}}
               {push_back [batch_notes_keys] $dx_keys_note}
            }
            ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "[batch_notes_keys] = " [batch_notes_keys]}}}
            ;{if {&& {> {size [batch_notes_keys]} 0} [log_enabled_keys]} {dx_log_writer countdown {sprint "[batch_notes_keys].0 = " {elem [batch_notes_keys] 0}}}}
            ;{if {&& {> {size [batch_notes_keys]} 0} [log_enabled_keys]} {dx_log_writer countdown {sprint "[batch_notes_keys].0.0 = " {elem {elem [batch_notes_keys] 0} 0}}}}
            ;{if {&& {> {size [batch_notes_keys]} 0} [log_enabled_keys]} {dx_log_writer countdown {sprint "[batch_notes_keys].0.1 = " {elem {elem [batch_notes_keys] 0} 1}}}}
            
            ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "Currently " {size [batch_notes_keys]} " notes in cache"}}}
            ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "finished parsing note"}}}
         }
      }
   )
   (term 
      ;{dx_log_writer countdown {sprint "TERM"}}
      {if $dx_perfects_indicator
         ; Add any hanging notes to the keys_note_tracker_2
         {if {> {size [batch_notes_keys]} 0}
            {set [diff_end_found_keys] FALSE}
            {if {> {size [batch_notes_keys]} 1}
               ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "set $first_end to " {elem {elem [batch_notes_keys] 0} 1} }}}
               {set $first_end {elem {elem [batch_notes_keys] 0} 1}}
               {foreach $n [batch_notes_keys] 
                  ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "checking note " $n " for different end time, using value " {elem $n 1}}}}
                  {if {!= {elem $n 1} $first_end}
                     {set [diff_end_found_keys] TRUE}
                  }
               }
               ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "[diff_end_found_keys] = " [diff_end_found_keys]}}}
            }

            ; Push all notes if there's a differing end
            {if_else {== [diff_end_found_keys] TRUE}
               {foreach $n [batch_notes_keys] {do
                  ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "pushing back note with time " {elem $n 0}}}}
                  {push_back $keys_note_tracker_2 {* {beat_to_seconds {elem $n 0}} 1000}}
               }}
               {do
                  {set $n {elem [batch_notes_keys] 0}}
                  ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "pushing back singular note with time " {elem $n 0}}}}
                  {push_back $keys_note_tracker_2 {* {beat_to_seconds {elem $n 0}} 1000}}
               }
            }
            
            {set $keys_note_tracker_2_size {size $keys_note_tracker_2}}
            ;{if [log_enabled_keys] {dx_log_writer countdown {sprint "set $keys_note_tracker_2_size = " $keys_note_tracker_2_size}}}
         }
      }
   )
}
{new
   MidiParser
   keys_overdrive_timer
   (track_name 'PART KEYS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (116)
   )
   (midi
      {push_back $keys_note_tracker ({sprint "overdrive_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $keys_note_tracker {array $keys_note_tracker}}
   )
}
{new
   MidiParser
   keys_solo_timer
   (track_name 'PART KEYS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (103)
   )
   (midi
      {push_back $keys_note_tracker ({sprint "solo_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $keys_note_tracker {array $keys_note_tracker}}
   )
}
{new
   MidiParser
   real_keys_timer
   (track_name 'PART REAL_KEYS_X')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 115 116 120) ;115: solo, 116: glissando, 120: BRE
   )
   (midi
      ;{$this rt_compute_space}
      {unless $first_real_keys_gem_tracked
         {set $first_real_keys_gem_tracked TRUE}
         {set [dx_batch_start_beat_real_keys] -1}
         {set [batch_notes_real_keys] {array ()}}
         {set $tracked_break_num_real_keys 0}
         {set $dx_last_note_started_real_keys 0} ; cache note start time
         {set $first_real_keys_gem_beat {int $mp.start}}
         {set [log_enabled_real_keys] TRUE}
         {if {> $first_real_keys_gem_beat 16}
            {push_back $real_keys_note_tracker ("delay_0" 0 $first_real_keys_gem_beat)}
            {set $real_keys_note_tracker {array $real_keys_note_tracker}}
            {set $tracked_break_num_real_keys 1}
         }
      }
      {if {&& {>= $mp.prev_end 16} {< $mp.prev_end 10000}}
         {set $real_keys_tracked_start {int $mp.start}}
         {set $real_keys_tracked_prev_end {int {- $real_keys_tracked_start $mp.prev_end}}}
         {push_back $real_keys_note_tracker ({sprint "delay_" $tracked_break_num_real_keys} $real_keys_tracked_prev_end $real_keys_tracked_start)}
         {set $real_keys_note_tracker {array $real_keys_note_tracker}}
         {set $tracked_break_num_real_keys {+ $tracked_break_num_real_keys 1}}
      }
      {set $dx_final_note_real_keys {int $mp.end}}
      {if {> $dx_final_note_real_keys $dx_final_note} {set $dx_final_note $dx_final_note_real_keys}}
      {if $dx_perfects_indicator
         ;Thanks again ChatGPT
         ; Parse the 25-note range (limited by the allowed_notes attribute) 
         {if {&& {!= $mp.val 115} {!= $mp.val 116} {!= $mp.val 120}}
            {if [log_enabled_real_keys] 
               {set [log_enabled_real_keys] {if_else {< {beat_to_seconds $mp.start} 60}
                                             TRUE
                                             FALSE}
               }
            }
            ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "starting parsing note"}}}
            ;{if {<= $real_keys_note_tracker_2_size 4000}
               ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint $real_keys_note_tracker_2_size "," {* {beat_to_seconds $mp.start} 1000} "," {* {beat_to_seconds $mp.end} 1000} "," $mp.start "," $mp.end "," [dx_batch_start_beat_real_keys] "," $mp.length "," $mp.prev_start "," $mp.prev_end "," $mp.data "," $mp.val }}}
            ;}

            ; If this note starts a new batch
            {if {> {- $mp.start [dx_batch_start_beat_real_keys]} 0.02} ;changed from an equality check; fix for ever so slightly desynchronised notes, eg. https://rhythmverse.co/songfile/61304c77b01252.88654892
               ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "new start time, process batch of " {size [batch_notes_real_keys]} " notes"}}}
               
               ; Process previous batch (if any)
               {if {> {size [batch_notes_real_keys]} 0}
                  {set [diff_end_found_real_keys] FALSE}
                  {if {> {size [batch_notes_real_keys]} 1}
                     ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "set $first_end to " {elem {elem [batch_notes_real_keys] 0} 1} }}}
                     {set $first_end {elem {elem [batch_notes_real_keys] 0} 1}}
                     {foreach $n [batch_notes_real_keys] 
                        ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "checking note " $n " for different end time, using value " {elem $n 1}}}}
                        {if {!= {elem $n 1} $first_end}
                           {set [diff_end_found_real_keys] TRUE}
                        }
                     }
                     ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "[diff_end_found_real_keys] = " [diff_end_found_real_keys]}}}
                  }

                  ; Push all notes if there's a differing end
                  {if_else {== [diff_end_found_real_keys] TRUE}
                     {foreach $n [batch_notes_real_keys] {do
                        ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "pushing back note with time " {elem $n 0}}}}
                        {push_back $real_keys_note_tracker_2 {* {beat_to_seconds {elem $n 0}} 1000}}
                     }}
                     {do
                        {set $n {elem [batch_notes_real_keys] 0}}
                        ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "pushing back singular note with time " {elem $n 0}}}}
                        {push_back $real_keys_note_tracker_2 {* {beat_to_seconds {elem $n 0}} 1000}}
                     }
                  }
                  
                  {set $real_keys_note_tracker_2_size {size $real_keys_note_tracker_2}}
                  ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "set $real_keys_note_tracker_2_size = " $real_keys_note_tracker_2_size}}}
               }

               ; Start new batch
               ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "set [dx_batch_start_beat_real_keys] to " $mp.start}}}
               {set [dx_batch_start_beat_real_keys] $mp.start}
               ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "[dx_batch_start_beat_real_keys] = " [dx_batch_start_beat_real_keys] ", set [batch_notes_real_keys] to empty array"}}}
               {set [batch_notes_real_keys] {array ()}} ; Clear batch
            }

            ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "push back $dx_real_keys_note to [batch_notes_real_keys]"}}}
            {set [dx_do_add_note_real_keys] TRUE}
            {if {> {size [batch_notes_real_keys]} 0}
               {foreach $n [batch_notes_real_keys]
                  ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "Checking for no matching note val " {elem $n 2}}}}
                  {if {== {elem $n 2} $mp.val}
                     ;{dx_log_writer countdown {sprint "Second+ note with same start-time and val, skipping!"}}
                     {set [dx_do_add_note_real_keys] FALSE}
                  }
               }
            }
            {if {== [dx_do_add_note_real_keys] TRUE} 
               {set $dx_real_keys_note {array ($mp.start $mp.end $mp.val)}}
               ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "$dx_real_keys_note = " $dx_real_keys_note}}}
               {push_back [batch_notes_real_keys] $dx_real_keys_note}
            }
            ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "[batch_notes_real_keys] = " [batch_notes_real_keys]}}}
            ;{if {&& {> {size [batch_notes_real_keys]} 0} {[log_enabled_real_keys]}} {dx_log_writer countdown {sprint "[batch_notes_real_keys].0 = " {elem [batch_notes_real_keys] 0}}}}
            ;{if {&& {> {size [batch_notes_real_keys]} 0} {[log_enabled_real_keys]}} {dx_log_writer countdown {sprint "[batch_notes_real_keys].0.0 = " {elem {elem [batch_notes_real_keys] 0} 0}}}}
            ;{if {&& {> {size [batch_notes_real_keys]} 0} {[log_enabled_real_keys]}} {dx_log_writer countdown {sprint "[batch_notes_real_keys].0.1 = " {elem {elem [batch_notes_real_keys] 0} 1}}}}
            
            ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "Currently " {size [batch_notes_real_keys]} " notes in cache"}}}
            ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "finished parsing note"}}}
         }
      }
   )
   (term 
      ;{dx_log_writer countdown {sprint "TERM"}}
      {if $dx_perfects_indicator
         ; Add any hanging notes to the real_keys_note_tracker_2
         {if {> {size [batch_notes_real_keys]} 0}
            {set [diff_end_found_real_keys] FALSE}
            {if {> {size [batch_notes_real_keys]} 1}
               ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "set $first_end to " {elem {elem [batch_notes_real_keys] 0} 1} }}}
               {set $first_end {elem {elem [batch_notes_real_keys] 0} 1}}
               {foreach $n [batch_notes_real_keys] 
                  ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "checking note " $n " for different end time, using value " {elem $n 1}}}}
                  {if {!= {elem $n 1} $first_end}
                     {set [diff_end_found_real_keys] TRUE}
                  }
               }
               ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "[diff_end_found_real_keys] = " [diff_end_found_real_keys]}}}
            }

            ; Push all notes if there's a differing end
            {if_else {== [diff_end_found_real_keys] TRUE}
               {foreach $n [batch_notes_real_keys] {do
                  ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "pushing back note with time " {elem $n 0}}}}
                  {push_back $real_keys_note_tracker_2 {* {beat_to_seconds {elem $n 0}} 1000}}
               }}
               {do
                  {set $n {elem [batch_notes_real_keys] 0}}
                  ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "pushing back singular note with time " {elem $n 0}}}}
                  {push_back $real_keys_note_tracker_2 {* {beat_to_seconds {elem $n 0}} 1000}}
               }
            }
            
            {set $real_keys_note_tracker_2_size {size $real_keys_note_tracker_2}}
            ;{if [log_enabled_real_keys] {dx_log_writer countdown {sprint "set $real_keys_note_tracker_2_size = " $real_keys_note_tracker_2_size}}}
         }
      }
   )
}
{new
   MidiParser
   real_keys_overdrive_timer
   (track_name 'PART REAL_KEYS_X')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (116)
   )
   (midi
      {push_back $real_keys_note_tracker ({sprint "overdrive_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $real_keys_note_tracker {array $real_keys_note_tracker}}
   )
}
{new
   MidiParser
   real_keys_solo_timer
   (track_name 'PART REAL_KEYS_X')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (115)
   )
   (midi
      {push_back $real_keys_note_tracker ({sprint "solo_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $real_keys_note_tracker {array $real_keys_note_tracker}}
   )
}
#ifdef RB3DX
{new
   MidiParser
   vocals_timer
   (track_name 'PART VOCALS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (105 106)
   )
   (midi
      ;{$this rt_compute_space}
      {unless $first_vocals_gem_tracked
         {set $first_vocals_gem_tracked TRUE}
         {set $tracked_break_num_vocals 0}
         {set $first_vocals_gem_beat {int $mp.start}}
         {if {> $first_vocals_gem_beat 16}
            {push_back $vocals_note_tracker ("delay_0" 0 $first_vocals_gem_beat)}
            {set $vocals_note_tracker {array $vocals_note_tracker}}
            {set $tracked_break_num_vocals 1}
         }
      }
      {if {&& {>= $mp.prev_end 16} {< $mp.prev_end 10000}}
         {set $vocals_tracked_start {int $mp.start}}
         {set $vocals_tracked_prev_end {int {- $vocals_tracked_start $mp.prev_end}}}
         {push_back $vocals_note_tracker ({sprint "delay_" $tracked_break_num_vocals} $vocals_tracked_prev_end $vocals_tracked_start)}
         {set $vocals_note_tracker {array $vocals_note_tracker}}
         {set $tracked_break_num_vocals {+ $tracked_break_num_vocals 1}}
      }
      {set $dx_final_note_vocals {int $mp.end}}
      {if {> $dx_final_note_vocals $dx_final_note} {set $dx_final_note $dx_final_note_vocals}}
   )
}
{new
   MidiParser
   vocals_overdrive_timer
   (track_name 'PART VOCALS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (116)
   )
   (midi
      {push_back $vocals_note_tracker ({sprint "overdrive_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $vocals_note_tracker {array $vocals_note_tracker}}
   )
}
{new
   MidiParser
   vocals_solo_timer
   (track_name 'PART VOCALS')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (103)
   )
   (midi
      {push_back $vocals_note_tracker ({sprint "solo_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $vocals_note_tracker {array $vocals_note_tracker}}
   )
}
{new
   MidiParser
   harm_timer
   (track_name 'HARM1')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (105 106)
   )
   (midi
      ;{$this rt_compute_space}
      {unless $first_harm_gem_tracked
         {set $first_harm_gem_tracked TRUE}
         {set $tracked_break_num_harm 0}
         {set $first_harm_gem_beat {int $mp.start}}
         {if {> $first_harm_gem_beat 16}
            {push_back $harm_note_tracker ("delay_0" 0 $first_harm_gem_beat)}
            {set $harm_note_tracker {array $harm_note_tracker}}
            {set $tracked_break_num_harm 1}
         }
      }
      {if {&& {>= $mp.prev_end 16} {< $mp.prev_end 10000}}
         {set $harm_tracked_start {int $mp.start}}
         {set $harm_tracked_prev_end {int {- $harm_tracked_start $mp.prev_end}}}
         {push_back $harm_note_tracker ({sprint "delay_" $tracked_break_num_harm} $harm_tracked_prev_end $harm_tracked_start)}
         {set $harm_note_tracker {array $harm_note_tracker}}
         {set $tracked_break_num_harm {+ $tracked_break_num_harm 1}}
      }
      {set $dx_final_note_harm {int $mp.end}}
      {if {> $dx_final_note_harm $dx_final_note} {set $dx_final_note $dx_final_note_harm}}
   )
}
{new
   MidiParser
   harm_overdrive_timer
   (track_name 'HARM1')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (116)
   )
   (midi
      {push_back $harm_note_tracker ({sprint "overdrive_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $harm_note_tracker {array $harm_note_tracker}}
   )
}
{new
   MidiParser
   harm_solo_timer
   (track_name 'PART harm')
   (inverted FALSE)
   (up FALSE)
   (append_length TRUE)
   (compress TRUE)
   ;(message_type midi_parser)
   (mp.up FALSE)
   (idle)
   (allowed_notes
      (103)
   )
   (midi
      {push_back $harm_note_tracker ({sprint "solo_" {int $mp.start}} {int $mp.start} {int $mp.end})}
      {set $harm_note_tracker {array $harm_note_tracker}}
   )
}
#endif